# MindReel SQLite Database Schema

This document outlines the database schema for the MindReel application, designed for local storage using SQLite.

## 1. List of Tables

### `entries`

Stores individual activity entries created by the user.

| Column Name    | Data Type | Constraints                                              | Description                                                        |
| :------------- | :-------- | :------------------------------------------------------- | :----------------------------------------------------------------- |
| `id`           | `INTEGER` | `PRIMARY KEY AUTOINCREMENT`                              | Unique identifier for the entry.                                   |
| `content`      | `TEXT`    | `NOT NULL`                                               | The text content of the activity entry.                            |
| `date`         | `TEXT`    | `NOT NULL`                                               | The date of the entry in 'YYYY-MM-DD' format, derived from `created_at`. |
| `week_of_year` | `INTEGER` | `NOT NULL`                                               | The ISO week number of the year, derived from `created_at`.        |
| `created_at`   | `TEXT`    | `NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))` | ISO 8601 timestamp of when the entry was created.                  |

### `summaries`

Stores the weekly AI-generated summaries.

| Column Name    | Data Type | Constraints                                              | Description                                                        |
| :------------- | :-------- | :------------------------------------------------------- | :----------------------------------------------------------------- |
| `id`           | `INTEGER` | `PRIMARY KEY AUTOINCREMENT`                              | Unique identifier for the summary.                                 |
| `content`      | `TEXT`    | `NOT NULL`                                               | The generated content of the weekly summary.                       |
| `start_date`   | `TEXT`    | `NOT NULL`                                               | The start date (Monday) of the summarized week (ISO 8601 format).  |
| `end_date`     | `TEXT`    | `NOT NULL`                                               | The end date (Sunday) of the summarized week (ISO 8601 format).    |
| `week_of_year` | `INTEGER` | `NOT NULL`                                               | The ISO week number of the year for the summary.                   |
| `created_at`   | `TEXT`    | `NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))` | ISO 8601 timestamp of when the summary was generated.              |

### `settings`

A single-row table to store user-specific application settings.

| Column Name               | Data Type | Constraints                  | Description                                                        |
| :------------------------ | :-------- | :--------------------------- | :----------------------------------------------------------------- |
| `id`                      | `INTEGER` | `PRIMARY KEY CHECK (id = 1)` | Ensures only one row of settings exists.                           |
| `popup_interval_minutes`  | `INTEGER` | `NOT NULL DEFAULT 60`        | Frequency of the "What are you working on?" pop-up in minutes.     |
| `global_shortcut`         | `TEXT`    | `NULL`                       | The global keyboard shortcut for adding a new entry.               |


## 2. Relationships Between Tables

The database is designed for a single-user, local-first application, so direct foreign key relationships are kept minimal to maintain simplicity.

-   **`entries` and `summaries`**: There is no direct foreign key relationship. The connection is temporal. A weekly summary in the `summaries` table is generated by processing all records from the `entries` table where `week_of_year` matches.
-   **`settings`**: This table is not directly related to `entries` or `summaries` via foreign keys

## 3. Indexes

To ensure efficient querying of data, especially as the number of entries grows.

-   **`idx_entries_date`**: An index on the `date` column of the `entries` table.
    ```sql
    CREATE INDEX idx_entries_date ON entries(date);
    ```
    This is crucial for performance when fetching entries for a specific day to display in the UI.

-   **`idx_summaries_week`**: An index on the `week_of_year` column of the `summaries` table.
    ```sql
    CREATE INDEX idx_summaries_week ON summaries(week_of_year);
    ```
    This will speed up queries that look for summaries for a specific week.

## 4. PostgreSQL Policies

Not applicable. The database is SQLite, which does not support Row-Level Security (RLS) policies. All data is stored locally on the user's machine, and access control is managed at the application and filesystem level.

## 5. Additional Notes and Design Decisions

-   **Data Types**: Standard SQLite data types are used. Dates and timestamps are stored as `TEXT` in the ISO 8601 format (`YYYY-MM-DDTHH:MM:SS.SSSZ`). This format is human-readable, easily parsable in JavaScript (`new Date()`), and allows for correct chronological sorting.
-   **Derived Columns**: The `date` and `week_of_year` columns in the `entries` table are intended to be derived from the `created_at` timestamp at the application level upon insertion. This denormalization simplifies queries for grouping entries by day or week, which is a core feature of the application.
-   **Default Timestamps**: The `created_at` columns use `strftime` to automatically set the creation timestamp in UTC, ensuring consistency regardless of the user's local time zone.
-   **Normalization**: The schema is mostly in Third Normal Form (3NF), with the deliberate denormalization of `date` and `week_of_year` for performance reasons, avoiding repeated date calculations in queries.
-   **Single-Row `settings` Table**: The `CHECK (id = 1)` constraint is a standard SQLite pattern to enforce a singleton table, which is perfect for global application settings. The application logic should attempt to `INSERT` a default row with `id = 1` and handle the constraint failure if the row already exists.
