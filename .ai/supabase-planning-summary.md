<conversation_summary>
<decisions>

1. Use only Supabase `auth.users` (email, id, created_at); no extra profile table in MVP.
2. Track only current 28-day AI summary quota (no lifetime or historical metrics).
3. Quota limit: 5 AI summaries per 28-day cycle.
4. Cycle anchored by per-user `cycle_start_at`; reset when `now() >= cycle_start_at + interval '28 days'`.
5. On reset, `ai_summaries_count` set to 0 and `cycle_start_at = now()` (even if multiple cycles elapsed).
6. Quota row stored in dedicated table `user_ai_quota(user_id pk, ai_summaries_count, cycle_start_at, updated_at)`.
7. First successful summary generation lazily creates quota row with count = 1.
8. API call to OpenRouter performed first; only on success is quota check/reset/increment attempted.
9. If increment step fails after a successful API call, store summary anyway without increment (user gets a “free” summary).
10. Concurrency race risk accepted; at worst user may reach 6 summaries in a cycle.
11. No user-visible remaining quota endpoint for MVP.
12. RLS: allow SELECT for owning user; deny INSERT/UPDATE/DELETE to normal users.
13. All mutations occur through a `SECURITY DEFINER` function `public.increment_ai_summary()` owned by service role.
14. Function logic: upsert row, perform reset if due, check limit (<5), increment if allowed, update `updated_at`.
15. `updated_at` maintained inside the function (no trigger).
16. No additional indexes beyond primary key.
17. No idempotency or event duplication handling (client won’t duplicate).
18. Failure to increment due to race will still cap practical abuse (accepted).
    </decisions>

<matched_recommendations>

1. Dedicated quota table separate from `auth.users`.
2. Transactional RPC for atomic check/reset/increment.
3. Interval-based cycle reset using `now() >= cycle_start_at + interval '28 days'`.
4. Lazy initialization of quota row on first successful generation.
5. Post-success increment to avoid burning quota on failed API calls.
6. RLS read-only + `SECURITY DEFINER` mutation function pattern.
7. Minimal schema now; extensibility preserved via separate table.
8. Avoid premature indexing (PK sufficient).
9. Acceptance of limited race risk instead of added complexity.
10. In-function maintenance of `updated_at` (simple integrity approach).
    </matched_recommendations>

<database_planning_summary>
The MVP Supabase database concerns only authentication and AI summary quota enforcement. Authentication relies entirely on Supabase `auth.users` (email, id, created_at). A single application table `user_ai_quota` maintains per-user quota state for AI summary generation.

Table: user_ai_quota

- user_id uuid primary key references auth.users(id) on delete cascade
- ai_summaries_count int not null default 0
- cycle_start_at timestamptz not null
- updated_at timestamptz not null default now()

Quota semantics:

- Fixed-length 28-day cycle starting at `cycle_start_at`.
- Reset condition: `now() >= cycle_start_at + interval '28 days'`.
- On reset: set count to 0 and `cycle_start_at = now()`.
- Limit: 5 summaries per cycle; accepted race condition may allow transient 6.
- Inactive users returning after multiple cycles still reset to now (no multi-advance logic).

Operational flow:

1. Generate summary via OpenRouter API call (external) first.
2. If success, call `public.increment_ai_summary()` (SECURITY DEFINER).
3. Function upserts row (if missing: initializes `cycle_start_at = now()`, `ai_summaries_count = 0` before logic).
4. Applies reset if needed.
5. If `ai_summaries_count >= 5` after reset, returns limit status (client discards summary or handles denial).
6. Else increments `ai_summaries_count`, sets `updated_at = now()`, returns success.
7. If the function fails after API success, summary is still stored (no increment).

Security:

- RLS enabled on `user_ai_quota`.
- Policy: SELECT where `auth.uid() = user_id`.
- No policies permitting INSERT/UPDATE/DELETE for normal users.
- Only `public.increment_ai_summary()` (SECURITY DEFINER, owned by service role) performs mutations, bypassing RLS safely.
- Users cannot manipulate quota directly, reducing abuse vectors.

Scalability:

- O(1) lookup and update per generation.
- Low contention expected; acceptable race tolerance.
- Schema easily extensible for future counters (add columns) or history (add ledger table) without migration complexity now.

Integrity:

- Atomic transaction inside function ensures consistent reset plus increment.
- `updated_at` maintained manually for potential auditing or client freshness checks.
- No idempotency token since duplicate events are not generated by design.

Future extensibility considerations (implicit):

- Can add columns (e.g., `daily_limit_count`, `plan`) without affecting existing logic.
- Historical tracking could be added via a `user_ai_quota_history` table if needed later.

The design meets MVP objectives with minimal complexity while enforcing quota and preserving a straightforward path for future evolution.

</database_planning_summary>

<unresolved_issues>
None.
</unresolved_issues>
</conversation_summary>
